"""
Tests for WebSocket Chat Functionality

This module contains comprehensive tests for WebSocket-based real-time chat
functionality in the helpdesk system.
"""

import pytest
import json
from fastapi.testclient import TestClient
from unittest.mock import AsyncMock, patch, MagicMock
from bson import ObjectId

from main import app
from app.services.websocket_manager import ConnectionManager
from app.schemas.message import MessageRole, MessageType, MessageFeedback


@pytest.fixture
def test_client():
    """Create test client"""
    return TestClient(app)


@pytest.fixture
def mock_connection_manager():
    """Create mock connection manager"""
    manager = MagicMock(spec=ConnectionManager)
    manager.connect = AsyncMock()
    manager.disconnect = AsyncMock()
    manager.send_personal_message = AsyncMock()
    manager.broadcast_to_ticket = AsyncMock()
    manager.active_connections = {}
    return manager


@pytest.fixture
def valid_jwt_token():
    """Create a valid JWT token for testing"""
    # This would normally be generated by your auth service
    # For testing, we'll mock the decode function
    return "valid_test_token"


@pytest.fixture
def test_user_data():
    """Test user data"""
    return {
        "user_id": str(ObjectId()),
        "user_role": "user",
        "username": "testuser"
    }


@pytest.fixture
def test_ticket_id():
    """Test ticket ID"""
    return str(ObjectId())


class TestWebSocketAuthentication:
    """Test WebSocket authentication functionality"""

    @patch('app.routers.ws_chat.decode_access_token')
    def test_authenticate_websocket_user_success(self, mock_decode):
        """Test successful WebSocket authentication"""
        from app.routers.ws_chat import authenticate_websocket_user
        
        # Mock successful token decode
        mock_decode.return_value = {
            "sub": "user123",
            "role": "user"
        }
        
        # This would be async in real implementation
        # For testing, we'll verify the mock is called correctly
        mock_decode.assert_not_called()  # Not called yet
        
        # In actual test, you'd await the function
        # result = await authenticate_websocket_user("valid_token")
        # assert result["user_id"] == "user123"
        # assert result["user_role"] == "user"

    @patch('app.routers.ws_chat.decode_access_token')
    def test_authenticate_websocket_user_invalid_token(self, mock_decode):
        """Test WebSocket authentication with invalid token"""
        from app.routers.ws_chat import authenticate_websocket_user
        
        # Mock token decode failure
        mock_decode.side_effect = Exception("Invalid token")
        
        # In actual async test:
        # with pytest.raises(HTTPException):
        #     await authenticate_websocket_user("invalid_token")

    @patch('app.routers.ws_chat.ticket_service')
    def test_verify_ticket_access_success(self, mock_ticket_service):
        """Test successful ticket access verification"""
        from app.routers.ws_chat import verify_ticket_access
        
        # Mock successful ticket retrieval
        mock_ticket_service.get_ticket_by_id_with_role = AsyncMock(return_value={"id": "ticket123"})
        
        # In actual async test:
        # result = await verify_ticket_access("user123", "user", "ticket123")
        # assert result is True

    @patch('app.routers.ws_chat.ticket_service')
    def test_verify_ticket_access_denied(self, mock_ticket_service):
        """Test ticket access denial"""
        from app.routers.ws_chat import verify_ticket_access
        
        # Mock no ticket found (access denied)
        mock_ticket_service.get_ticket_by_id_with_role = AsyncMock(return_value=None)
        
        # In actual async test:
        # result = await verify_ticket_access("user123", "user", "ticket123")
        # assert result is False


class TestWebSocketMessageHandling:
    """Test WebSocket message handling functionality"""

    @patch('app.routers.ws_chat.message_service')
    @patch('app.routers.ws_chat.connection_manager')
    def test_handle_chat_message_success(self, mock_manager, mock_message_service):
        """Test successful chat message handling"""
        from app.routers.ws_chat import handle_chat_message
        from app.schemas.message import WebSocketMessageSchema
        
        # Mock message service
        mock_saved_message = MagicMock()
        mock_saved_message._id = ObjectId()
        mock_saved_message.timestamp = MagicMock()
        mock_saved_message.timestamp.isoformat.return_value = "2023-01-01T00:00:00"
        
        mock_message_service.save_message = AsyncMock(return_value=mock_saved_message)
        mock_manager.broadcast_to_ticket = AsyncMock()
        
        # Create test message
        ws_message = WebSocketMessageSchema(
            type="chat",
            ticket_id="ticket123",
            content="Test message",
            message_type=MessageType.USER_MESSAGE,
            isAI=False,
            feedback=MessageFeedback.NONE
        )
        
        # In actual async test:
        # await handle_chat_message(ws_message, "user123", "user", "conn123")
        # mock_message_service.save_message.assert_called_once()
        # mock_manager.broadcast_to_ticket.assert_called_once()

    def test_websocket_message_schema_validation(self):
        """Test WebSocket message schema validation"""
        from app.schemas.message import WebSocketMessageSchema
        
        # Valid message
        valid_data = {
            "type": "chat",
            "ticket_id": "ticket123",
            "content": "Test message"
        }
        
        message = WebSocketMessageSchema(**valid_data)
        assert message.type == "chat"
        assert message.ticket_id == "ticket123"
        assert message.content == "Test message"
        assert message.message_type == MessageType.USER_MESSAGE  # Default
        assert message.isAI is False  # Default
        assert message.feedback == MessageFeedback.NONE  # Default

    def test_websocket_message_schema_validation_empty_content(self):
        """Test WebSocket message schema validation with empty content"""
        from app.schemas.message import WebSocketMessageSchema
        
        invalid_data = {
            "type": "chat",
            "ticket_id": "ticket123",
            "content": ""  # Empty content should fail
        }
        
        with pytest.raises(ValueError, match="Content cannot be empty"):
            WebSocketMessageSchema(**invalid_data)

    def test_websocket_message_schema_validation_long_content(self):
        """Test WebSocket message schema validation with long content"""
        from app.schemas.message import WebSocketMessageSchema
        
        invalid_data = {
            "type": "chat",
            "ticket_id": "ticket123",
            "content": "x" * 1001  # Exceeds 1000 character limit
        }
        
        with pytest.raises(ValueError, match="Content cannot exceed 1000 characters"):
            WebSocketMessageSchema(**invalid_data)


class TestConnectionManager:
    """Test WebSocket connection manager functionality"""

    def test_connection_manager_initialization(self):
        """Test connection manager initialization"""
        manager = ConnectionManager()
        
        assert manager.active_connections == {}
        assert manager.rooms == {}
        assert manager.user_connections == {}

    def test_generate_connection_id(self):
        """Test connection ID generation"""
        manager = ConnectionManager()
        
        conn_id = manager._generate_connection_id("user123", "ticket456")
        
        assert "user123" in conn_id
        assert "ticket456" in conn_id
        assert len(conn_id.split("_")) == 3  # user_id, ticket_id, timestamp

    def test_get_room_id(self):
        """Test room ID generation"""
        manager = ConnectionManager()
        
        room_id = manager._get_room_id("ticket123")
        
        assert room_id == "ticket_ticket123"

    def test_get_room_members_empty(self):
        """Test getting members of non-existent room"""
        manager = ConnectionManager()
        
        members = manager.get_room_members("nonexistent_ticket")
        
        assert members == []

    def test_connection_count(self):
        """Test connection count tracking"""
        manager = ConnectionManager()
        
        assert manager.get_connection_count() == 0
        
        # Simulate adding connections
        manager.active_connections["conn1"] = MagicMock()
        manager.active_connections["conn2"] = MagicMock()
        
        assert manager.get_connection_count() == 2

    def test_room_count(self):
        """Test room count tracking"""
        manager = ConnectionManager()
        
        assert manager.get_room_count() == 0
        
        # Simulate adding rooms
        manager.rooms["room1"] = {}
        manager.rooms["room2"] = {}
        
        assert manager.get_room_count() == 2


class TestWebSocketIntegration:
    """Integration tests for WebSocket functionality"""

    def test_websocket_endpoint_exists(self, test_client):
        """Test that WebSocket endpoint is properly registered"""
        # This tests that the route exists, but actual WebSocket testing
        # requires more sophisticated setup with websocket test clients
        
        # Check if the route is in the app's routes
        websocket_routes = [route for route in app.routes if hasattr(route, 'path') and '/ws/chat' in route.path]
        assert len(websocket_routes) > 0

    @patch('app.routers.ws_chat.authenticate_websocket_user')
    @patch('app.routers.ws_chat.verify_ticket_access')
    def test_websocket_connection_flow_mocked(self, mock_verify_access, mock_auth):
        """Test WebSocket connection flow with mocked dependencies"""
        # Mock successful authentication and access verification
        mock_auth.return_value = {"user_id": "user123", "user_role": "user"}
        mock_verify_access.return_value = True
        
        # In a real test, you would use a WebSocket test client here
        # This is a placeholder to show the test structure
        assert True  # Placeholder assertion


class TestMessageSchemas:
    """Test message-related schemas"""

    def test_message_create_schema_valid(self):
        """Test valid message creation schema"""
        from app.schemas.message import MessageCreateSchema
        
        data = {
            "content": "Test message content",
            "message_type": MessageType.USER_MESSAGE,
            "isAI": False,
            "feedback": MessageFeedback.NONE
        }
        
        schema = MessageCreateSchema(**data)
        assert schema.content == "Test message content"
        assert schema.message_type == MessageType.USER_MESSAGE
        assert schema.isAI is False
        assert schema.feedback == MessageFeedback.NONE

    def test_message_create_schema_defaults(self):
        """Test message creation schema with defaults"""
        from app.schemas.message import MessageCreateSchema
        
        data = {"content": "Test message"}
        
        schema = MessageCreateSchema(**data)
        assert schema.content == "Test message"
        assert schema.message_type == MessageType.USER_MESSAGE  # Default
        assert schema.isAI is False  # Default
        assert schema.feedback == MessageFeedback.NONE  # Default

    def test_message_create_schema_content_validation(self):
        """Test message creation schema content validation"""
        from app.schemas.message import MessageCreateSchema
        
        # Test empty content
        with pytest.raises(ValueError):
            MessageCreateSchema(content="")
        
        # Test whitespace-only content
        with pytest.raises(ValueError):
            MessageCreateSchema(content="   ")
        
        # Test content too long
        with pytest.raises(ValueError):
            MessageCreateSchema(content="x" * 1001)
