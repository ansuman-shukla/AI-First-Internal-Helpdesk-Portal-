"""
Message Model

This module defines the Message model for MongoDB operations
in the helpdesk system's real-time chat functionality.
"""

import logging
from datetime import datetime
from typing import Optional, Dict, Any
from bson import ObjectId
from app.schemas.message import MessageRole, MessageType, MessageFeedback

logger = logging.getLogger(__name__)


class MessageModel:
    """
    Message model for MongoDB operations
    
    Represents a chat message within a ticket with all necessary
    metadata for real-time communication and feedback tracking.
    """

    def __init__(
        self,
        ticket_id: ObjectId,
        sender_id: ObjectId,
        sender_role: MessageRole,
        content: str,
        message_type: MessageType = MessageType.USER_MESSAGE,
        isAI: bool = False,
        feedback: MessageFeedback = MessageFeedback.NONE,
        timestamp: Optional[datetime] = None,
        _id: Optional[ObjectId] = None
    ):
        """
        Initialize a new message
        
        Args:
            ticket_id: ObjectId of the associated ticket
            sender_id: ObjectId of the message sender
            sender_role: Role of the message sender
            content: Message content (1-1000 characters)
            message_type: Type of message (user/agent/system)
            isAI: Whether message was generated by AI
            feedback: Feedback rating for the message
            timestamp: Message timestamp (auto-generated if None)
            _id: MongoDB ObjectId (auto-generated if None)
        """
        self._id = _id
        self.ticket_id = ticket_id
        self.sender_id = sender_id
        self.sender_role = sender_role
        self.message_type = message_type
        self.content = content
        self.isAI = isAI
        self.feedback = feedback
        self.timestamp = timestamp or datetime.utcnow()

        # Validate content
        self._validate_content()

        logger.debug(
            f"Created message model - Ticket: {ticket_id}, Sender: {sender_id}, "
            f"Role: {sender_role.value}, Type: {message_type.value}, AI: {isAI}"
        )

    def _validate_content(self) -> None:
        """Validate message content"""
        if not isinstance(self.content, str):
            raise ValueError("Content must be a string")
        
        content = self.content.strip()
        if not content:
            raise ValueError("Content cannot be empty or only whitespace")
        
        if len(content) > 1000:
            raise ValueError("Content cannot exceed 1000 characters")
        
        # Update with cleaned content
        self.content = content

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert message to dictionary for MongoDB storage
        
        Returns:
            Dictionary representation of the message
        """
        message_dict = {
            "ticket_id": self.ticket_id,
            "sender_id": self.sender_id,
            "sender_role": self.sender_role.value,
            "message_type": self.message_type.value,
            "content": self.content,
            "isAI": self.isAI,
            "feedback": self.feedback.value,
            "timestamp": self.timestamp
        }
        
        if self._id:
            message_dict["_id"] = self._id
            
        return message_dict

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MessageModel":
        """
        Create message from dictionary (MongoDB document)
        
        Args:
            data: Dictionary containing message data
            
        Returns:
            MessageModel instance
        """
        try:
            return cls(
                _id=data.get("_id"),
                ticket_id=data["ticket_id"],
                sender_id=data["sender_id"],
                sender_role=MessageRole(data["sender_role"]),
                message_type=MessageType(data["message_type"]),
                content=data["content"],
                isAI=data.get("isAI", False),
                feedback=MessageFeedback(data.get("feedback", MessageFeedback.NONE.value)),
                timestamp=data["timestamp"]
            )
        except KeyError as e:
            logger.error(f"Missing required field in message data: {e}")
            raise ValueError(f"Invalid message data: missing field {e}")
        except ValueError as e:
            logger.error(f"Invalid enum value in message data: {e}")
            raise ValueError(f"Invalid message data: {e}")

    def update_feedback(self, feedback: MessageFeedback) -> None:
        """
        Update message feedback rating
        
        Args:
            feedback: New feedback rating
        """
        old_feedback = self.feedback
        self.feedback = feedback
        
        logger.info(
            f"Updated message feedback - Message ID: {self._id}, "
            f"Old: {old_feedback.value}, New: {feedback.value}"
        )

    def __str__(self) -> str:
        """String representation of the message"""
        return (
            f"Message(id={self._id}, ticket_id={self.ticket_id}, "
            f"sender_role={self.sender_role.value}, type={self.message_type.value}, "
            f"content_length={len(self.content)}, isAI={self.isAI})"
        )

    def __repr__(self) -> str:
        """Detailed string representation of the message"""
        return (
            f"MessageModel(_id={self._id}, ticket_id={self.ticket_id}, "
            f"sender_id={self.sender_id}, sender_role={self.sender_role.value}, "
            f"message_type={self.message_type.value}, content='{self.content[:50]}...', "
            f"isAI={self.isAI}, feedback={self.feedback.value}, "
            f"timestamp={self.timestamp})"
        )
