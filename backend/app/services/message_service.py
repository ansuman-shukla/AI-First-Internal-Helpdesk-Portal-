"""
Message Service

This module provides database operations for message management
in the helpdesk system's real-time chat functionality.
"""

import logging
from datetime import datetime
from typing import List, Optional, Dict, Any
from bson import ObjectId
from pymongo.errors import PyMongoError

from app.core.database import get_database
from app.models.message import MessageModel
from app.schemas.message import MessageRole, MessageType, MessageFeedback, MessageCreateSchema

logger = logging.getLogger(__name__)


class MessageService:
    """Service class for message database operations"""

    def __init__(self):
        self.db = None
        self.collection = None

    def _ensure_db_connection(self):
        """Ensure database connection is established"""
        if self.db is None:
            self.db = get_database()
            if self.db is not None:
                self.collection = self.db.messages

    async def save_message(
        self,
        ticket_id: str,
        sender_id: str,
        sender_role: MessageRole,
        content: str,
        message_type: MessageType = MessageType.USER_MESSAGE,
        isAI: bool = False,
        feedback: MessageFeedback = MessageFeedback.NONE
    ) -> MessageModel:
        """
        Save a new message to the database
        
        Args:
            ticket_id: ID of the associated ticket
            sender_id: ID of the message sender
            sender_role: Role of the message sender
            content: Message content
            message_type: Type of message
            isAI: Whether message was generated by AI
            feedback: Feedback rating for the message
            
        Returns:
            MessageModel: The created message
            
        Raises:
            ValueError: If validation fails
            Exception: If database operation fails
        """
        try:
            # Ensure database connection
            self._ensure_db_connection()
            if self.collection is None:
                raise Exception("Database connection not available")

            # Convert string IDs to ObjectIds
            ticket_object_id = ObjectId(ticket_id)
            sender_object_id = ObjectId(sender_id)
            
            # Create message model
            message_model = MessageModel(
                ticket_id=ticket_object_id,
                sender_id=sender_object_id,
                sender_role=sender_role,
                content=content,
                message_type=message_type,
                isAI=isAI,
                feedback=feedback,
                timestamp=datetime.utcnow()
            )
            
            # Insert into database
            result = await self.collection.insert_one(message_model.to_dict())
            message_model._id = result.inserted_id
            
            logger.info(
                f"Successfully saved message - Ticket: {ticket_id}, Sender: {sender_id}, "
                f"Role: {sender_role.value}, Type: {message_type.value}, AI: {isAI}"
            )
            
            return message_model
            
        except ValueError as e:
            logger.error(f"Validation error saving message: {e}")
            raise
        except PyMongoError as e:
            logger.error(f"Database error saving message: {e}")
            raise Exception(f"Failed to save message: {str(e)}")
        except Exception as e:
            logger.error(f"Unexpected error saving message: {e}")
            raise Exception(f"Failed to save message: {str(e)}")

    async def get_ticket_messages(
        self,
        ticket_id: str,
        limit: int = 50,
        skip: int = 0,
        sort_order: int = 1  # 1 for ascending (oldest first), -1 for descending
    ) -> List[MessageModel]:
        """
        Get messages for a specific ticket
        
        Args:
            ticket_id: ID of the ticket
            limit: Maximum number of messages to return
            skip: Number of messages to skip (for pagination)
            sort_order: Sort order (1 for oldest first, -1 for newest first)
            
        Returns:
            List[MessageModel]: List of messages for the ticket
        """
        try:
            # Ensure database connection
            self._ensure_db_connection()
            if self.collection is None:
                raise Exception("Database connection not available")

            ticket_object_id = ObjectId(ticket_id)
            
            cursor = self.collection.find(
                {"ticket_id": ticket_object_id}
            ).sort("timestamp", sort_order).skip(skip).limit(limit)
            
            messages = []
            async for doc in cursor:
                try:
                    message = MessageModel.from_dict(doc)
                    messages.append(message)
                except ValueError as e:
                    logger.warning(f"Skipping invalid message document: {e}")
                    continue
            
            logger.debug(
                f"Retrieved {len(messages)} messages for ticket {ticket_id} "
                f"(limit: {limit}, skip: {skip})"
            )
            
            return messages
            
        except Exception as e:
            logger.error(f"Error retrieving messages for ticket {ticket_id}: {e}")
            raise Exception(f"Failed to retrieve messages: {str(e)}")

    async def get_message_by_id(self, message_id: str) -> Optional[MessageModel]:
        """
        Get a specific message by ID
        
        Args:
            message_id: ID of the message
            
        Returns:
            MessageModel or None if not found
        """
        try:
            # Ensure database connection
            self._ensure_db_connection()
            if self.collection is None:
                raise Exception("Database connection not available")

            message_object_id = ObjectId(message_id)
            
            doc = await self.collection.find_one({"_id": message_object_id})
            
            if doc:
                message = MessageModel.from_dict(doc)
                logger.debug(f"Retrieved message {message_id}")
                return message
            else:
                logger.debug(f"Message {message_id} not found")
                return None
                
        except Exception as e:
            logger.error(f"Error retrieving message {message_id}: {e}")
            raise Exception(f"Failed to retrieve message: {str(e)}")

    async def update_message_feedback(
        self,
        message_id: str,
        feedback: MessageFeedback
    ) -> bool:
        """
        Update feedback for a specific message
        
        Args:
            message_id: ID of the message
            feedback: New feedback rating
            
        Returns:
            bool: True if update was successful
        """
        try:
            # Ensure database connection
            self._ensure_db_connection()
            if self.collection is None:
                raise Exception("Database connection not available")

            message_object_id = ObjectId(message_id)

            result = await self.collection.update_one(
                {"_id": message_object_id},
                {"$set": {"feedback": feedback.value}}
            )
            
            if result.modified_count > 0:
                logger.info(f"Updated feedback for message {message_id} to {feedback.value}")
                return True
            else:
                logger.warning(f"No message found with ID {message_id} for feedback update")
                return False
                
        except Exception as e:
            logger.error(f"Error updating message feedback {message_id}: {e}")
            raise Exception(f"Failed to update message feedback: {str(e)}")

    async def get_all_ticket_messages(self, ticket_id: str) -> List[MessageModel]:
        """
        Get ALL messages for a specific ticket (no pagination) for summarization purposes.

        Args:
            ticket_id: ID of the ticket

        Returns:
            List[MessageModel]: All messages for the ticket, sorted by timestamp (oldest first)
        """
        try:
            # Ensure database connection
            self._ensure_db_connection()
            if self.collection is None:
                raise Exception("Database connection not available")

            ticket_object_id = ObjectId(ticket_id)

            cursor = self.collection.find(
                {"ticket_id": ticket_object_id}
            ).sort("timestamp", 1)  # Oldest first for chronological order

            messages = []
            async for doc in cursor:
                try:
                    message = MessageModel.from_dict(doc)
                    messages.append(message)
                except ValueError as e:
                    logger.warning(f"Skipping invalid message document: {e}")
                    continue

            logger.debug(f"Retrieved all {len(messages)} messages for ticket {ticket_id}")
            return messages

        except Exception as e:
            logger.error(f"Error retrieving all messages for ticket {ticket_id}: {e}")
            raise Exception(f"Failed to retrieve messages: {str(e)}")

    async def get_message_count_for_ticket(self, ticket_id: str) -> int:
        """
        Get the total number of messages for a ticket

        Args:
            ticket_id: ID of the ticket

        Returns:
            int: Number of messages
        """
        try:
            # Ensure database connection
            self._ensure_db_connection()
            if self.collection is None:
                raise Exception("Database connection not available")

            ticket_object_id = ObjectId(ticket_id)
            count = await self.collection.count_documents({"ticket_id": ticket_object_id})

            logger.debug(f"Ticket {ticket_id} has {count} messages")
            return count

        except Exception as e:
            logger.error(f"Error counting messages for ticket {ticket_id}: {e}")
            raise Exception(f"Failed to count messages: {str(e)}")

    async def delete_messages_for_ticket(self, ticket_id: str) -> int:
        """
        Delete all messages for a specific ticket
        
        Args:
            ticket_id: ID of the ticket
            
        Returns:
            int: Number of messages deleted
        """
        try:
            # Ensure database connection
            self._ensure_db_connection()
            if self.collection is None:
                raise Exception("Database connection not available")

            ticket_object_id = ObjectId(ticket_id)

            result = await self.collection.delete_many({"ticket_id": ticket_object_id})
            
            logger.info(f"Deleted {result.deleted_count} messages for ticket {ticket_id}")
            return result.deleted_count
            
        except Exception as e:
            logger.error(f"Error deleting messages for ticket {ticket_id}: {e}")
            raise Exception(f"Failed to delete messages: {str(e)}")


# Global service instance
message_service = MessageService()
